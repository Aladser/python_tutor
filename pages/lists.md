# Списки

`arr = []` создание списка

`arr.append(val)` добавление элемента

`arr.remove(element)` удаляет первый совпадающий элемент из списка.

`arr.pop(index)` удаляет элемент на основе переданного индекса.

`arr.clear()` удаляет все элементы из списка.

`print(*arr)` вывод элементов списка

`split(sep)` возвращает список строк, получаемый из исходной, разрезанной символом `sep`. По умолчанию `sep` - пробел

`sep.join(arr)` выводит список элементов в одну строку через разделитель sep


> `arr = ['red', 'green', 'blue']`

> `print(' '.join(arr))`

> `# вернёт red green blue`

Операции:

* конкатенация списков (сложение списков, т. е. приписывание к одному списку другого)
  `arr2.extend(arr1)`

  `arr3 = arr1 + arr2` 
* повторение списков (умножение списка на число)
   
  `arr2 = arr1 * 3`

## Генераторы списков

Для создания списков, заполненных по более сложным формулам можно использовать генераторы: выражения, позволяющие заполнить список некоторой формулой. Общий вид генератора:

`[выражение for переменная in последовательность]`

где *переменная* — идентификатор некоторой переменной, *последовательность* — последовательность значений, который принимает данная переменная (это может быть список, строка или объект, полученный при помощи функции range), *выражение* — некоторое выражение, как правило, зависящее от использованной в генераторе переменной, которым будут заполнены элементы списка.

Создать список, заполненный квадратами целых чиселк:

`n = 5`

`a = [i ** 2 for i in range(n)]`

## Срезы

`A[i:j]`  срез из j-i элементов A[i], A[i+1], ..., A[j-1].

`A[i:j:-1]`  срез из i-j элементов A[i], A[i-1], ..., A[j+1] (то есть меняется порядок элементов).

`A[i:j:k]`  срез с шагом k: A[i], A[i+k], A[i+2*k],... . Если значение k<0, то элементы идут в противоположном порядке.

## Операции со списками

`x in arr`	проверяет, содержится ли элемент в списке. Возвращает True или False

`x not in arr`	равнозначно not(x in A)

`arr.min(A)`	наименьший элемент списка

`arr.max(A)`	наибольший элемент списка

`arr.index(x)`	индекс первого вхождения элемента x в список, при его отсутствии генерирует исключение ValueError

`arr.count(x)`	количество вхождений элемента x в список

## Двумерные массивы. Создание вложенных списков

`arr = [[0] * m for i in range(n)]`


`arr = [[int(j) for j in input().split()] for i in range(n)]`


`arr = [[0 for j in range(m)] for i in range(n)]`

## Сортировка

`sorted()` - сортировка по возрастанию, которая вернёт новый отсортированный список:

`sorted([5, 2, 3, 1, 4])`

[1, 2, 3, 4, 5]

`list.sort()`- изменяет исходный список.
``a = [5, 2, 3, 1, 4]`
 `a.sort()`
>[1, 2, 3, 4, 5]`

Ещё одно отличие заключается в том, что метод list.sort() определён только для списков, в то время как sorted() работает со всеми итерируемыми объектами:

`sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})

>[1, 2, 3, 4, 5]`

При итерировании по словарю Python возвращает его ключи. Если вам нужны их значения или пары «ключ-значение», используйте методы dict.values() и dict.items() соответственно.

### Функции-ключи

С версии Python 2.4 у list.sort() и sorted() появился параметр key для указания функции, которая будет вызываться на каждом элементе до сравнения. Вот регистронезависимое сравнение строк:

`sorted("This is a test string from Andrew".split(), key=str.lower)`

> ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']`

Значение key должно быть функцией, принимающей один аргумент и возвращающей ключ для сортировки. Работает быстро, потому что функция-ключ вызывается один раз для каждого элемента.

`student_tuples = [`

`        ('john', 'A', 15),`

`        ('jane', 'B', 12),`
        
`        ('dave', 'B', 10),`
`    ]`
`sorted(student_tuples, key=lambda student: student[2])   # сортируем по возрасту`
 
> [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]`

У list.sort() и sorted() есть параметр `reverse`, принимающий boolean-значение. Он нужен для обозначения сортировки по убыванию. Отсортируем учеников по убыванию возраста:

`sorted(student_tuples, key=itemgetter(2), reverse=True)``

> [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]`

`sorted(student_objects, key=attrgetter('age'), reverse=True)`

> [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]`

