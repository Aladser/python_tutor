# Списки

## Операции со списками

`arr = []` создание списка.

`arr.append(val)` добавление элемента.

``list.insert(index, x)`` - Добавляет элемент x в список на позицию index.

`arr.extend()` добавляет указанные элементы в конец списка.

`arr.remove(element)` удаляет первый совпадающий элемент из списка.

`arr.pop(index)` удаляет элемент на основе переданного индекса.

`arr.clear()` удаляет все элементы из списка.

`print(*arr)` вывод элементов списка.

`split(sep)` возвращает список строк, получаемый из исходной, разрезанной символом `sep`. По умолчанию `sep` - пробел.

`sep.join(arr)` выводит список элементов в одну строку через разделитель sep.
`x in arr`	проверяет, содержится ли элемент в списке. Возвращает True или False.

`reverse()` переворачивает список.

`x not in arr`	равнозначно not(x in A).

`arr.min(A)`	наименьший элемент списка.

`arr.max(A)`	наибольший элемент списка.

`arr.index(x)`	индекс первого вхождения элемента x в список, при его отсутствии генерирует исключение ValueError.

`arr.count(x)`	количество вхождений элемента x в список.

`arr2.extend(arr1)` или `arr3 = arr1 + arr2` конкатенация списков (сложение списков, т. е. приписывание к одному списку другого).
   
`arr2 = arr1 * 3` повторение списков (умножение списка на число).

``copy.copy(x)`` - возвращает поверхностную копию x. Поверхностная копия создает новый составной объект, и затем (по мере возможности) вставляет в него ссылки на объекты, находящиеся в оригинале.

``copy.deepcopy(x)`` - возвращает полную копию x. Глубокая копия создает новый составной объект, и затем рекурсивно вставляет в него копии объектов, находящихся в оригинале.

## Генераторы списков

Для создания списков, заполненных по более сложным формулам можно использовать генераторы: выражения, позволяющие заполнить список некоторой формулой. Общий вид генератора:

`[выражение for переменная in последовательность]`

где *переменная* — идентификатор некоторой переменной, *последовательность* — последовательность значений, который принимает данная переменная (это может быть список, строка или объект, полученный при помощи функции range), *выражение* — некоторое выражение, как правило, зависящее от использованной в генераторе переменной, которым будут заполнены элементы списка.

Создать список, заполненный квадратами целых чиселк:

`n = 5`

`a = [i ** 2 for i in range(n)]`

## Срезы

`A[i:j]`  срез из j-i элементов A[i], A[i+1], ..., A[j-1].

`A[i:j:-1]`  срез из i-j элементов A[i], A[i-1], ..., A[j+1] (то есть меняется порядок элементов).

`A[i:j:k]`  срез с шагом k: A[i], A[i+k], A[i+2*k],... . Если значение k<0, то элементы идут в противоположном порядке.

#### Использование срезов для изменения элементов в заданном диапазоне

`fruits = ['apple', 'apricot', 'banana', 'cherry', 'kiwi', 'lemon', 'mango']`

`fruits[2:5] = ['банан', 'вишня', 'киви']`

`print(fruits)`

> ['apple', 'apricot', 'банан', 'вишня', 'киви', 'lemon', 'mango']

## Двумерные массивы. Создание вложенных списков

`arr = [[0] * m for i in range(n)]`


`arr = [[int(j) for j in input().split()] for i in range(n)]`


`arr = [[0 for j in range(m)] for i in range(n)]`

## Сортировка

`sorted()` - сортировка по возрастанию, которая вернёт новый отсортированный список:

`sorted([5, 2, 3, 1, 4])`

> [1, 2, 3, 4, 5]

`list.sort()- изменяет исходный список.`

> a = [5, 2, 3, 1, 4]

 `a.sort()`
 
>[1, 2, 3, 4, 5]

Ещё одно отличие заключается в том, что метод list.sort() определён только для списков, в то время как sorted() работает со всеми итерируемыми объектами:

`sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})`

>[1, 2, 3, 4, 5]

При итерировании по словарю Python возвращает его ключи. Если вам нужны их значения или пары «ключ-значение», используйте методы dict.values() и dict.items() соответственно.

### Функции-ключи

С версии Python 2.4 у list.sort() и sorted() появился параметр key для указания функции, которая будет вызываться на каждом элементе до сравнения. Вот регистронезависимое сравнение строк:

`sorted("This is a test string from Andrew".split(), key=str.lower)`

> ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']`

Значение key должно быть функцией, принимающей один аргумент и возвращающей ключ для сортировки. Работает быстро, потому что функция-ключ вызывается один раз для каждого элемента.

`student_tuples = [`

`        ('john', 'A', 15),`

`        ('jane', 'B', 12),`
        
`        ('dave', 'B', 10),`
`    ]`
`sorted(student_tuples, key=lambda student: student[2])   # сортируем по возрасту`
 
> [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]`

У list.sort() и sorted() есть параметр `reverse`, принимающий boolean-значение. Он нужен для обозначения сортировки по убыванию. Отсортируем учеников по убыванию возраста:

`sorted(student_tuples, key=itemgetter(2), reverse=True)`

> [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]`

`sorted(student_objects, key=attrgetter('age'), reverse=True)`

> [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]`

